##装饰者模式

动态的将责任附加到对象上，若要扩展功能，提供了比继承更有弹性的替代方案

1.装饰者和被装饰对象有相同的超类型
2.可以用一个或者多个装饰者包装同一个对象
3.装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，达到特定的目的

使用继承达到 “类型匹配”而不是通过集成获得行为， 装饰者和被装饰者有相同的接口，是因为装饰者必须可以
取代被装饰者，行为使用过装饰者与组件组合获得的

java中的InputStream 是装饰类实例

被装饰的子类继承一个父类
一个负责装饰的类 集成该父类
装饰器继承负责装饰的类

缺点： 会造成大量重复的类，装饰时需要一层层嵌套，增加失误，但是可以通过结合工厂模式来创建对象